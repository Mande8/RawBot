                        .module functions.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./functions.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./functions.c
 0000           _lcdBuffer::
 0000                   .blkb 1
                        .area idata(rom,lit)
 0000 00                .byte 0
                        .area data(ram, con, rel)
 0001                   .dbfile ./functions.c
 0001                   .blkb 7
                        .area idata(rom,lit)
 0001 00000000000000    .byte 0,0,0,0,0,0,0
                        .area data(ram, con, rel)
 0008                   .dbfile ./functions.c
 0008                   .blkb 24
                        .area idata(rom,lit)
 0008 00000000000000000000      .word 0,0,0,0,0
 0012 00000000000000000000      .word 0,0,0,0,0
 001C 00000000          .byte 0,0,0,0
                        .area data(ram, con, rel)
 0020                   .dbfile ./functions.c
 0020                   .dbfile C:\Projects\RawBot\RawBot\functions.c
 0020                   .dbsym e lcdBuffer _lcdBuffer A[32:4:8]c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Projects\RawBot\RawBot\functions.c
 0000                   .dbfunc e servoStart _servoStart fV
 0000           ;         period -> X-5
 0000           _servoStart::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002                   .dbline 15
 0002           ; /*************
 0002           ; *  Includes  *
 0002           ; *************/
 0002           ; 
 0002           ; #include "Functions.h"
 0002           ; #include <m8c.h>
 0002           ; #include "PSoCAPI.h"
 0002           ; 
 0002           ; char lcdBuffer[4][8] = {0};
 0002           ; 
 0002           ; /**********
 0002           ; *  Servo  *
 0002           ; **********/
 0002           ; 
 0002           ; void servoStart(unsigned int period) {
 0002                   .dbline 16
 0002           ;       ServoPWM_WritePeriod(period);
 0002 10                push X
 0003 52FB              mov A,[X-5]
 0005 08                push A
 0006 52FC              mov A,[X-4]
 0008 20                pop X
 0009 7C0000            xcall _ServoPWM_WritePeriod
 000C                   .dbline 17
 000C           ;       ServoPWM_Start();       
 000C 7C0000            xcall _ServoPWM_Start
 000F 20                pop X
 0010                   .dbline -2
 0010           L1:
 0010 20                pop X
 0011                   .dbline 0 ; func end
 0011 7F                ret
 0012                   .dbsym l period -5 i
 0012                   .dbend
 0012                   .dbfunc e servoStop _servoStop fV
 0012           _servoStop::
 0012                   .dbline -1
 0012                   .dbline 20
 0012           ; }
 0012           ; 
 0012           ; void servoStop(void) {
 0012                   .dbline 21
 0012           ;       ServoPWM_Stop(); // Just for uniformity
 0012 10                push X
 0013 7C0000            xcall _ServoPWM_Stop
 0016 20                pop X
 0017                   .dbline -2
 0017           L2:
 0017                   .dbline 0 ; func end
 0017 7F                ret
 0018                   .dbend
 0018                   .dbfunc e servoMove _servoMove fV
 0018           ;          range -> X-9
 0018           ;         middle -> X-7
 0018           ;          angle -> X-5
 0018           _servoMove::
 0018                   .dbline -1
 0018 10                push X
 0019 4F                mov X,SP
 001A                   .dbline 25
 001A           ; }
 001A           ; 
 001A           ; // Servo moving
 001A           ; void servoMove(int angle, unsigned int middle, unsigned int range) {
 001A                   .dbline 26
 001A           ;       ServoPWM_WritePulseWidth(middle + (angle*((range*2)/180)));
 001A 52F8              mov A,[X-8]
 001C 5300              mov [__r1],A
 001E 52F7              mov A,[X-9]
 0020 5300              mov [__r0],A
 0022 6500              asl [__r1]
 0024 6B00              rlc [__r0]
 0026 5000              mov A,0
 0028 08                push A
 0029 50B4              mov A,-76
 002B 08                push A
 002C 5100              mov A,[__r0]
 002E 08                push A
 002F 5100              mov A,[__r1]
 0031 08                push A
 0032 7C0000            xcall __divmodu_16X16_16
 0035 18                pop A
 0036 5300              mov [__r1],A
 0038 18                pop A
 0039 38FE              add SP,-2
 003B 08                push A
 003C 5100              mov A,[__r1]
 003E 08                push A
 003F 52FB              mov A,[X-5]
 0041 08                push A
 0042 52FC              mov A,[X-4]
 0044 08                push A
 0045 7C0000            xcall __mul16
 0048 38FC              add SP,-4
 004A 5F0000            mov [__r1],[__rX]
 004D 5F0000            mov [__r0],[__rY]
 0050 52FA              mov A,[X-6]
 0052 0200              add A,[__r1]
 0054 5300              mov [__r1],A
 0056 52F9              mov A,[X-7]
 0058 0A00              adc A,[__r0]
 005A 10                push X
 005B 08                push A
 005C 5100              mov A,[__r1]
 005E 20                pop X
 005F 7C0000            xcall _ServoPWM_WritePulseWidth
 0062 20                pop X
 0063                   .dbline -2
 0063           L3:
 0063 20                pop X
 0064                   .dbline 0 ; func end
 0064 7F                ret
 0065                   .dbsym l range -9 i
 0065                   .dbsym l middle -7 i
 0065                   .dbsym l angle -5 I
 0065                   .dbend
 0065                   .dbfunc e usTrigSend _usTrigSend fV
 0065           _usTrigSend::
 0065                   .dbline -1
 0065                   .dbline 33
 0065           ; }
 0065           ; 
 0065           ; /***************
 0065           ; *  Ultrasound  *
 0065           ; ***************/
 0065           ; 
 0065           ; void usTrigSend(void) {
 0065                   .dbline 34
 0065           ;       digitalWrite(0, 6, 1); // Start the trigger signal
 0065 5001              mov A,1
 0067 08                push A
 0068 5006              mov A,6
 006A 08                push A
 006B 5000              mov A,0
 006D 08                push A
 006E 92E3              xcall _digitalWrite
 0070 38FD              add SP,-3
 0072                   .dbline 35
 0072           ;       Timer8UsTrig_Start(); // Used to measure 10us trigger pulse
 0072 10                push X
 0073 7C0000            xcall _Timer8UsTrig_Start
 0076 20                pop X
 0077                   .dbline -2
 0077           L4:
 0077                   .dbline 0 ; func end
 0077 7F                ret
 0078                   .dbend
 0078                   .dbfunc e usCalculateDistance _usCalculateDistance fI
 0078           ;      usRawTime -> X-7
 0078           _usCalculateDistance::
 0078                   .dbline -1
 0078 10                push X
 0079 4F                mov X,SP
 007A                   .dbline 38
 007A           ; }
 007A           ; 
 007A           ; int usCalculateDistance(unsigned long usRawTime) {
 007A                   .dbline 39
 007A           ;       return (((46400 - usRawTime) / 2) / 58);
 007A 5040              mov A,64
 007C 13FC              sub A,[X-4]
 007E 5300              mov [__r3],A
 0080 50B5              mov A,-75
 0082 1BFB              sbb A,[X-5]
 0084 5300              mov [__r2],A
 0086 5000              mov A,0
 0088 1BFA              sbb A,[X-6]
 008A 5300              mov [__r1],A
 008C 5000              mov A,0
 008E 1BF9              sbb A,[X-7]
 0090 5300              mov [__r0],A
 0092 70FB              and F,-5
 0094 6E00              rrc [__r0]
 0096 6E00              rrc [__r1]
 0098 6E00              rrc [__r2]
 009A 6E00              rrc [__r3]
 009C 5000              mov A,0
 009E 08                push A
 009F 08                push A
 00A0 08                push A
 00A1 503A              mov A,58
 00A3 08                push A
 00A4 5100              mov A,[__r0]
 00A6 08                push A
 00A7 5100              mov A,[__r1]
 00A9 08                push A
 00AA 5100              mov A,[__r2]
 00AC 08                push A
 00AD 5100              mov A,[__r3]
 00AF 08                push A
 00B0 7C0000            xcall __divmodu_32X32_32
 00B3 18                pop A
 00B4 5300              mov [__r3],A
 00B6 18                pop A
 00B7 5300              mov [__r2],A
 00B9 18                pop A
 00BA 18                pop A
 00BB 38FC              add SP,-4
 00BD 5F0000            mov [__r1],[__r3]
 00C0 5F0000            mov [__r0],[__r2]
 00C3                   .dbline -2
 00C3           L5:
 00C3 20                pop X
 00C4                   .dbline 0 ; func end
 00C4 7F                ret
 00C5                   .dbsym l usRawTime -7 l
 00C5                   .dbend
 00C5                   .dbfunc e drive _drive fV
 00C5           ;            dir -> X-4
 00C5           _drive::
 00C5                   .dbline -1
 00C5 10                push X
 00C6 4F                mov X,SP
 00C7 3802              add SP,2
 00C9                   .dbline 49
 00C9           ; }
 00C9           ; 
 00C9           ; /************
 00C9           ; *  Driving  *
 00C9           ; ************/
 00C9           ; 
 00C9           ; // Connections : H-bridge is connected to
 00C9           ; // Used to drive the H-Bridge; think of a numpad for controls
 00C9           ; // IN1 = Port0 Pin0 , IN2 = Port0 Pin1 etc
 00C9           ; void drive(unsigned char dir) {
 00C9                   .dbline 50
 00C9           ;       switch (dir) {
 00C9 52FC              mov A,[X-4]
 00CB 5401              mov [X+1],A
 00CD 560000            mov [X+0],0
 00D0 3D0000            cmp [X+0],0
 00D3 B006              jnz X0
 00D5 3D0102            cmp [X+1],2
 00D8 A02B              jz L10
 00DA           X0:
 00DA 3D0000            cmp [X+0],0
 00DD B006              jnz X1
 00DF 3D0104            cmp [X+1],4
 00E2 A029              jz L11
 00E4           X1:
 00E4 3D0000            cmp [X+0],0
 00E7 B006              jnz X2
 00E9 3D0105            cmp [X+1],5
 00EC A027              jz L12
 00EE           X2:
 00EE 3D0000            cmp [X+0],0
 00F1 B006              jnz X3
 00F3 3D0106            cmp [X+1],6
 00F6 A022              jz L13
 00F8           X3:
 00F8 3D0000            cmp [X+0],0
 00FB B006              jnz X4
 00FD 3D0108            cmp [X+1],8
 0100 A020              jz L14
 0102           X4:
 0102 8026              xjmp L7
 0104           L10:
 0104                   .dbline 52
 0104           ;               case 2: // Back (0101)
 0104           ;                       PRT0DR &= ~0x0A;
 0104 4100F5            and REG[0],-11
 0107                   .dbline 53
 0107           ;                       PRT0DR |= 0x05;
 0107 430005            or REG[0],5
 010A                   .dbline 54
 010A           ;                       break;
 010A 8021              xjmp L8
 010C           L11:
 010C                   .dbline 57
 010C           ;                       
 010C           ;               case 4: // Left (0110)
 010C           ;                       PRT0DR &= ~0x09;
 010C 4100F6            and REG[0],-10
 010F                   .dbline 58
 010F           ;                       PRT0DR |= 0x06;
 010F 430006            or REG[0],6
 0112                   .dbline 59
 0112           ;                       break;  
 0112 8019              xjmp L8
 0114           L12:
 0114                   .dbline 62
 0114           ;                       
 0114           ;               case 5: // Stop
 0114           ;                       PRT0DR &= ~0x0F; // All pins low;
 0114 4100F0            and REG[0],-16
 0117                   .dbline 63
 0117           ;                       break;
 0117 8014              xjmp L8
 0119           L13:
 0119                   .dbline 66
 0119           ;                       
 0119           ;               case 6: // Right (1001)
 0119           ;                       PRT0DR &= ~0x06;
 0119 4100F9            and REG[0],-7
 011C                   .dbline 67
 011C           ;                       PRT0DR |= 0x09;
 011C 430009            or REG[0],9
 011F                   .dbline 68
 011F           ;                       break;
 011F 800C              xjmp L8
 0121           L14:
 0121                   .dbline 71
 0121           ;               
 0121           ;               case 8: // Forward (1010)
 0121           ;                       PRT0DR &= ~0x05;
 0121 4100FA            and REG[0],-6
 0124                   .dbline 72
 0124           ;                       PRT0DR |= 0x0A;
 0124 43000A            or REG[0],10
 0127                   .dbline 73
 0127           ;                       break;
 0127 8004              xjmp L8
 0129           L7:
 0129                   .dbline 76
 0129           ;                       
 0129           ;               default:
 0129           ;                       PRT0DR &= ~0x0F; // All pins low;
 0129 4100F0            and REG[0],-16
 012C                   .dbline 77
 012C           ;                       break;
 012C           L8:
 012C                   .dbline -2
 012C           L6:
 012C 38FE              add SP,-2
 012E 20                pop X
 012F                   .dbline 0 ; func end
 012F 7F                ret
 0130                   .dbsym l dir -4 c
 0130                   .dbend
 0130                   .dbfunc e backlight _backlight fV
 0130           ;         toggle -> X-4
 0130           _backlight::
 0130                   .dbline -1
 0130 10                push X
 0131 4F                mov X,SP
 0132                   .dbline 87
 0132           ;       }       
 0132           ; }
 0132           ; 
 0132           ; 
 0132           ; 
 0132           ; /*****************
 0132           ; *  General PSoC  *
 0132           ; *****************/
 0132           ; 
 0132           ; void backlight(unsigned char toggle) {
 0132                   .dbline 88
 0132           ;       pinMode(2,7,1); // set the pin to strong
 0132 5001              mov A,1
 0134 08                push A
 0135 5007              mov A,7
 0137 08                push A
 0138 5002              mov A,2
 013A 08                push A
 013B 902C              xcall _pinMode
 013D 38FD              add SP,-3
 013F                   .dbline 89
 013F           ;       if (toggle == 0) { BL_Data_ADDR=(BL_DataShadow&=~BL_MASK); }
 013F 3DFC00            cmp [X-4],0
 0142 B00A              jnz L16
 0144                   .dbline 89
 0144                   .dbline 89
 0144 26007F            and [_Port_2_Data_SHADE],127
 0147 5100              mov A,[_Port_2_Data_SHADE]
 0149 6008              mov REG[0x8],A
 014B                   .dbline 89
 014B 801B              xjmp L17
 014D           L16:
 014D                   .dbline 90
 014D           ;       else if (toggle == 1) { BL_Data_ADDR=(BL_DataShadow|=BL_MASK); }
 014D 3DFC01            cmp [X-4],1
 0150 B00A              jnz L18
 0152                   .dbline 90
 0152                   .dbline 90
 0152 2E0080            or [_Port_2_Data_SHADE],-128
 0155 5100              mov A,[_Port_2_Data_SHADE]
 0157 6008              mov REG[0x8],A
 0159                   .dbline 90
 0159 800D              xjmp L19
 015B           L18:
 015B                   .dbline 91
 015B           ;       else if (toggle == 2) { BL_Data_ADDR=(BL_DataShadow^=BL_MASK); }
 015B 3DFC02            cmp [X-4],2
 015E B008              jnz L20
 0160                   .dbline 91
 0160                   .dbline 91
 0160 360080            xor [_Port_2_Data_SHADE],-128
 0163 5100              mov A,[_Port_2_Data_SHADE]
 0165 6008              mov REG[0x8],A
 0167                   .dbline 91
 0167           L20:
 0167           L19:
 0167           L17:
 0167                   .dbline -2
 0167           L15:
 0167 20                pop X
 0168                   .dbline 0 ; func end
 0168 7F                ret
 0169                   .dbsym l toggle -4 c
 0169                   .dbend
 0169                   .dbfunc e pinMode _pinMode fV
 0169           ;        bitMask -> X+2
 0169           ;              i -> X+0
 0169           ;          state -> X-6
 0169           ;            pin -> X-5
 0169           ;           port -> X-4
 0169           _pinMode::
 0169                   .dbline -1
 0169 10                push X
 016A 4F                mov X,SP
 016B 3805              add SP,5
 016D                   .dbline 95
 016D           ; }
 016D           ; 
 016D           ; // Sets the pin mode
 016D           ; void pinMode(unsigned char port, unsigned char pin, unsigned char state) {
 016D                   .dbline 97
 016D           ;       int i;
 016D           ;       BYTE bitMask = 1;
 016D 560201            mov [X+2],1
 0170                   .dbline 98
 0170           ;       for(i = 0; i < pin; i++) { bitMask *= 2; }
 0170 560100            mov [X+1],0
 0173 560000            mov [X+0],0
 0176 8008              xjmp L26
 0178           L23:
 0178                   .dbline 98
 0178                   .dbline 98
 0178 6602              asl [X+2]
 017A                   .dbline 98
 017A           L24:
 017A                   .dbline 98
 017A 7701              inc [X+1]
 017C 0F0000            adc [X+0],0
 017F           L26:
 017F                   .dbline 98
 017F 52FB              mov A,[X-5]
 0181 5300              mov [__r1],A
 0183 5201              mov A,[X+1]
 0185 1200              sub A,[__r1]
 0187 5000              mov A,0
 0189 3180              xor A,-128
 018B 5300              mov [__rX],A
 018D 5200              mov A,[X+0]
 018F 3180              xor A,-128
 0191 1A00              sbb A,[__rX]
 0193 CFE4              jc L23
 0195           X5:
 0195                   .dbline 100
 0195           ; 
 0195           ;       switch (state) {
 0195 52FA              mov A,[X-6]
 0197 5404              mov [X+4],A
 0199 560300            mov [X+3],0
 019C 3D0300            cmp [X+3],0
 019F B006              jnz X6
 01A1 3D0400            cmp [X+4],0
 01A4 A017              jz L30
 01A6           X6:
 01A6 3D0300            cmp [X+3],0
 01A9 B006              jnz X7
 01AB 3D0401            cmp [X+4],1
 01AE A091              jz L37
 01B0           X7:
 01B0 3D0300            cmp [X+3],0
 01B3 B006              jnz X8
 01B5 3D0403            cmp [X+4],3
 01B8 A10E              jz L44
 01BA           X8:
 01BA 8194              xjmp L28
 01BC           L30:
 01BC                   .dbline 102
 01BC           ;               case 0: // Resistive Pulldown
 01BC           ;                       if(port == 0) { PRT0DM2 &= ~bitMask; PRT0DM1 &= ~bitMask; PRT0DM0 &= ~bitMask; }
 01BC 3DFC00            cmp [X-4],0
 01BF B028              jnz L31
 01C1                   .dbline 102
 01C1                   .dbline 102
 01C1 5202              mov A,[X+2]
 01C3 73                cpl A
 01C4 5300              mov [__r0],A
 01C6 5D03              mov A,REG[0x3]
 01C8 2200              and A,[__r0]
 01CA 6003              mov REG[0x3],A
 01CC                   .dbline 102
 01CC 5202              mov A,[X+2]
 01CE 73                cpl A
 01CF 5300              mov [__r0],A
 01D1 7110              or F,0x10  ; iopage = 1
 01D3 5D01              mov A,REG[0x1]
 01D5 2200              and A,[__r0]
 01D7 6001              mov REG[0x1],A
 01D9                   .dbline 102
 01D9 5202              mov A,[X+2]
 01DB 73                cpl A
 01DC 5300              mov [__r0],A
 01DE 5D00              mov A,REG[0]
 01E0 2200              and A,[__r0]
 01E2 6000              mov REG[0],A
 01E4                   .dbline 102
 01E4 70CF              and F,0xCF      ; iopage = 0
 01E6 8168              xjmp L28
 01E8           L31:
 01E8                   .dbline 103
 01E8           ;                       else if(port == 1) { PRT1DM2 &= ~bitMask; PRT1DM1 &= ~bitMask; PRT1DM0 &= ~bitMask; }
 01E8 3DFC01            cmp [X-4],1
 01EB B028              jnz L33
 01ED                   .dbline 103
 01ED                   .dbline 103
 01ED 5202              mov A,[X+2]
 01EF 73                cpl A
 01F0 5300              mov [__r0],A
 01F2 5D07              mov A,REG[0x7]
 01F4 2200              and A,[__r0]
 01F6 6007              mov REG[0x7],A
 01F8                   .dbline 103
 01F8 5202              mov A,[X+2]
 01FA 73                cpl A
 01FB 5300              mov [__r0],A
 01FD 7110              or F,0x10  ; iopage = 1
 01FF 5D05              mov A,REG[0x5]
 0201 2200              and A,[__r0]
 0203 6005              mov REG[0x5],A
 0205                   .dbline 103
 0205 5202              mov A,[X+2]
 0207 73                cpl A
 0208 5300              mov [__r0],A
 020A 5D04              mov A,REG[0x4]
 020C 2200              and A,[__r0]
 020E 6004              mov REG[0x4],A
 0210                   .dbline 103
 0210 70CF              and F,0xCF      ; iopage = 0
 0212 813C              xjmp L28
 0214           L33:
 0214                   .dbline 104
 0214           ;                       else if(port == 2) { PRT2DM2 &= ~bitMask; PRT2DM1 &= ~bitMask; PRT2DM0 &= ~bitMask; }
 0214 3DFC02            cmp [X-4],2
 0217 B137              jnz L28
 0219                   .dbline 104
 0219                   .dbline 104
 0219 5202              mov A,[X+2]
 021B 73                cpl A
 021C 5300              mov [__r0],A
 021E 5D0B              mov A,REG[0xb]
 0220 2200              and A,[__r0]
 0222 600B              mov REG[0xb],A
 0224                   .dbline 104
 0224 5202              mov A,[X+2]
 0226 73                cpl A
 0227 5300              mov [__r0],A
 0229 7110              or F,0x10  ; iopage = 1
 022B 5D09              mov A,REG[0x9]
 022D 2200              and A,[__r0]
 022F 6009              mov REG[0x9],A
 0231                   .dbline 104
 0231 5202              mov A,[X+2]
 0233 73                cpl A
 0234 5300              mov [__r0],A
 0236 5D08              mov A,REG[0x8]
 0238 2200              and A,[__r0]
 023A 6008              mov REG[0x8],A
 023C                   .dbline 104
 023C                   .dbline 105
 023C           ;                       break;
 023C 70CF              and F,0xCF      ; iopage = 0
 023E 8110              xjmp L28
 0240           L37:
 0240                   .dbline 108
 0240           ;                       
 0240           ;               case 1: // Strong
 0240           ;                       if(port == 0) { PRT0DM2 &= ~bitMask; PRT0DM1 &= ~bitMask; PRT0DM0 |= bitMask; }
 0240 3DFC00            cmp [X-4],0
 0243 B029              jnz L38
 0245                   .dbline 108
 0245                   .dbline 108
 0245 5202              mov A,[X+2]
 0247 73                cpl A
 0248 5300              mov [__r0],A
 024A 5D03              mov A,REG[0x3]
 024C 2200              and A,[__r0]
 024E 6003              mov REG[0x3],A
 0250                   .dbline 108
 0250 5202              mov A,[X+2]
 0252 73                cpl A
 0253 5300              mov [__r0],A
 0255 7110              or F,0x10  ; iopage = 1
 0257 5D01              mov A,REG[0x1]
 0259 2200              and A,[__r0]
 025B 6001              mov REG[0x1],A
 025D                   .dbline 108
 025D 5D00              mov A,REG[0]
 025F 5300              mov [__r0],A
 0261 5202              mov A,[X+2]
 0263 2C00              or [__r0],A
 0265 5100              mov A,[__r0]
 0267 6000              mov REG[0],A
 0269                   .dbline 108
 0269 70CF              and F,0xCF      ; iopage = 0
 026B 80E3              xjmp L28
 026D           L38:
 026D                   .dbline 109
 026D           ;                       else if(port == 1) { PRT1DM2 &= ~bitMask; PRT1DM1 &= ~bitMask; PRT1DM0 |= bitMask; }
 026D 3DFC01            cmp [X-4],1
 0270 B029              jnz L40
 0272                   .dbline 109
 0272                   .dbline 109
 0272 5202              mov A,[X+2]
 0274 73                cpl A
 0275 5300              mov [__r0],A
 0277 5D07              mov A,REG[0x7]
 0279 2200              and A,[__r0]
 027B 6007              mov REG[0x7],A
 027D                   .dbline 109
 027D 5202              mov A,[X+2]
 027F 73                cpl A
 0280 5300              mov [__r0],A
 0282 7110              or F,0x10  ; iopage = 1
 0284 5D05              mov A,REG[0x5]
 0286 2200              and A,[__r0]
 0288 6005              mov REG[0x5],A
 028A                   .dbline 109
 028A 5D04              mov A,REG[0x4]
 028C 5300              mov [__r0],A
 028E 5202              mov A,[X+2]
 0290 2C00              or [__r0],A
 0292 5100              mov A,[__r0]
 0294 6004              mov REG[0x4],A
 0296                   .dbline 109
 0296 70CF              and F,0xCF      ; iopage = 0
 0298 80B6              xjmp L28
 029A           L40:
 029A                   .dbline 110
 029A           ;                       else if(port == 2) { PRT2DM2 &= ~bitMask; PRT2DM1 &= ~bitMask; PRT2DM0 |= bitMask; }
 029A 3DFC02            cmp [X-4],2
 029D B0B1              jnz L28
 029F                   .dbline 110
 029F                   .dbline 110
 029F 5202              mov A,[X+2]
 02A1 73                cpl A
 02A2 5300              mov [__r0],A
 02A4 5D0B              mov A,REG[0xb]
 02A6 2200              and A,[__r0]
 02A8 600B              mov REG[0xb],A
 02AA                   .dbline 110
 02AA 5202              mov A,[X+2]
 02AC 73                cpl A
 02AD 5300              mov [__r0],A
 02AF 7110              or F,0x10  ; iopage = 1
 02B1 5D09              mov A,REG[0x9]
 02B3 2200              and A,[__r0]
 02B5 6009              mov REG[0x9],A
 02B7                   .dbline 110
 02B7 5D08              mov A,REG[0x8]
 02B9 5300              mov [__r0],A
 02BB 5202              mov A,[X+2]
 02BD 2C00              or [__r0],A
 02BF 5100              mov A,[__r0]
 02C1 6008              mov REG[0x8],A
 02C3                   .dbline 110
 02C3                   .dbline 111
 02C3           ;                       break;
 02C3 70CF              and F,0xCF      ; iopage = 0
 02C5 8089              xjmp L28
 02C7           L44:
 02C7                   .dbline 114
 02C7           ;                       
 02C7           ;               case 3: // Pull up
 02C7           ;                       if(port == 0) { PRT0DM2 &= ~bitMask; PRT0DM1 |= bitMask; PRT0DM0 |= bitMask; }
 02C7 3DFC00            cmp [X-4],0
 02CA B02A              jnz L45
 02CC                   .dbline 114
 02CC                   .dbline 114
 02CC 5202              mov A,[X+2]
 02CE 73                cpl A
 02CF 5300              mov [__r0],A
 02D1 5D03              mov A,REG[0x3]
 02D3 2200              and A,[__r0]
 02D5 6003              mov REG[0x3],A
 02D7                   .dbline 114
 02D7 7110              or F,0x10  ; iopage = 1
 02D9 5D01              mov A,REG[0x1]
 02DB 5300              mov [__r0],A
 02DD 5202              mov A,[X+2]
 02DF 2C00              or [__r0],A
 02E1 5100              mov A,[__r0]
 02E3 6001              mov REG[0x1],A
 02E5                   .dbline 114
 02E5 5D00              mov A,REG[0]
 02E7 5300              mov [__r0],A
 02E9 5202              mov A,[X+2]
 02EB 2C00              or [__r0],A
 02ED 5100              mov A,[__r0]
 02EF 6000              mov REG[0],A
 02F1                   .dbline 114
 02F1 70CF              and F,0xCF      ; iopage = 0
 02F3 805B              xjmp L28
 02F5           L45:
 02F5                   .dbline 115
 02F5           ;                       else if(port == 1) { PRT1DM2 &= ~bitMask; PRT1DM1 |= bitMask; PRT1DM0 |= bitMask; }
 02F5 3DFC01            cmp [X-4],1
 02F8 B02A              jnz L47
 02FA                   .dbline 115
 02FA                   .dbline 115
 02FA 5202              mov A,[X+2]
 02FC 73                cpl A
 02FD 5300              mov [__r0],A
 02FF 5D07              mov A,REG[0x7]
 0301 2200              and A,[__r0]
 0303 6007              mov REG[0x7],A
 0305                   .dbline 115
 0305 7110              or F,0x10  ; iopage = 1
 0307 5D05              mov A,REG[0x5]
 0309 5300              mov [__r0],A
 030B 5202              mov A,[X+2]
 030D 2C00              or [__r0],A
 030F 5100              mov A,[__r0]
 0311 6005              mov REG[0x5],A
 0313                   .dbline 115
 0313 5D04              mov A,REG[0x4]
 0315 5300              mov [__r0],A
 0317 5202              mov A,[X+2]
 0319 2C00              or [__r0],A
 031B 5100              mov A,[__r0]
 031D 6004              mov REG[0x4],A
 031F                   .dbline 115
 031F 70CF              and F,0xCF      ; iopage = 0
 0321 802D              xjmp L28
 0323           L47:
 0323                   .dbline 116
 0323           ;                       else if(port == 2) { PRT2DM2 &= ~bitMask; PRT2DM1 |= bitMask; PRT2DM0 |= bitMask; }
 0323 3DFC02            cmp [X-4],2
 0326 B028              jnz L28
 0328                   .dbline 116
 0328                   .dbline 116
 0328 5202              mov A,[X+2]
 032A 73                cpl A
 032B 5300              mov [__r0],A
 032D 5D0B              mov A,REG[0xb]
 032F 2200              and A,[__r0]
 0331 600B              mov REG[0xb],A
 0333                   .dbline 116
 0333 7110              or F,0x10  ; iopage = 1
 0335 5D09              mov A,REG[0x9]
 0337 5300              mov [__r0],A
 0339 5202              mov A,[X+2]
 033B 2C00              or [__r0],A
 033D 5100              mov A,[__r0]
 033F 6009              mov REG[0x9],A
 0341                   .dbline 116
 0341 5D08              mov A,REG[0x8]
 0343 5300              mov [__r0],A
 0345 5202              mov A,[X+2]
 0347 2C00              or [__r0],A
 0349 5100              mov A,[__r0]
 034B 6008              mov REG[0x8],A
 034D                   .dbline 116
 034D                   .dbline 117
 034D           ;                       break;
 034D                   .dbline 120
 034D           ;                       
 034D           ;               default:
 034D           ;                       break;
 034D 70CF              and F,0xCF      ; iopage = 0
 034F           L28:
 034F                   .dbline -2
 034F           L22:
 034F 38FB              add SP,-5
 0351 20                pop X
 0352                   .dbline 0 ; func end
 0352 7F                ret
 0353                   .dbsym l bitMask 2 c
 0353                   .dbsym l i 0 I
 0353                   .dbsym l state -6 c
 0353                   .dbsym l pin -5 c
 0353                   .dbsym l port -4 c
 0353                   .dbend
 0353                   .dbfunc e digitalWrite _digitalWrite fV
 0353           ;        bitMask -> X+2
 0353           ;              i -> X+0
 0353           ;          state -> X-6
 0353           ;            pin -> X-5
 0353           ;           port -> X-4
 0353           _digitalWrite::
 0353                   .dbline -1
 0353 10                push X
 0354 4F                mov X,SP
 0355 3805              add SP,5
 0357                   .dbline 127
 0357           ;       } 
 0357           ; }
 0357           ; 
 0357           ; 
 0357           ; // Function for setting pins
 0357           ; // 0 = low, 1 = high, 2 = toggle
 0357           ; void digitalWrite(unsigned char port, unsigned char pin, unsigned char state) {
 0357                   .dbline 129
 0357           ;       int i ;
 0357           ;       BYTE bitMask = 1; 
 0357 560201            mov [X+2],1
 035A                   .dbline 130
 035A           ;       for(i = 0; i < pin; i++) { bitMask *= 2; }
 035A 560100            mov [X+1],0
 035D 560000            mov [X+0],0
 0360 8008              xjmp L55
 0362           L52:
 0362                   .dbline 130
 0362                   .dbline 130
 0362 6602              asl [X+2]
 0364                   .dbline 130
 0364           L53:
 0364                   .dbline 130
 0364 7701              inc [X+1]
 0366 0F0000            adc [X+0],0
 0369           L55:
 0369                   .dbline 130
 0369 52FB              mov A,[X-5]
 036B 5300              mov [__r1],A
 036D 5201              mov A,[X+1]
 036F 1200              sub A,[__r1]
 0371 5000              mov A,0
 0373 3180              xor A,-128
 0375 5300              mov [__rX],A
 0377 5200              mov A,[X+0]
 0379 3180              xor A,-128
 037B 1A00              sbb A,[__rX]
 037D CFE4              jc L52
 037F           X9:
 037F                   .dbline 132
 037F           ; 
 037F           ;       switch (state) {
 037F 52FA              mov A,[X-6]
 0381 5404              mov [X+4],A
 0383 560300            mov [X+3],0
 0386 3D0300            cmp [X+3],0
 0389 B006              jnz X10
 038B 3D0400            cmp [X+4],0
 038E A017              jz L59
 0390           X10:
 0390 3D0300            cmp [X+3],0
 0393 B006              jnz X11
 0395 3D0401            cmp [X+4],1
 0398 A043              jz L66
 039A           X11:
 039A 3D0300            cmp [X+3],0
 039D B006              jnz X12
 039F 3D0402            cmp [X+4],2
 03A2 A072              jz L73
 03A4           X12:
 03A4 80A7              xjmp L57
 03A6           L59:
 03A6                   .dbline 134
 03A6           ;               case 0:
 03A6           ;                       if(port == 0) PRT0DR &= ~bitMask;
 03A6 3DFC00            cmp [X-4],0
 03A9 B00E              jnz L60
 03AB                   .dbline 134
 03AB 5202              mov A,[X+2]
 03AD 73                cpl A
 03AE 5300              mov [__r0],A
 03B0 5D00              mov A,REG[0]
 03B2 2200              and A,[__r0]
 03B4 6000              mov REG[0],A
 03B6 8095              xjmp L57
 03B8           L60:
 03B8                   .dbline 135
 03B8           ;                       else if(port == 1) PRT1DR &= ~bitMask;
 03B8 3DFC01            cmp [X-4],1
 03BB B00E              jnz L62
 03BD                   .dbline 135
 03BD 5202              mov A,[X+2]
 03BF 73                cpl A
 03C0 5300              mov [__r0],A
 03C2 5D04              mov A,REG[0x4]
 03C4 2200              and A,[__r0]
 03C6 6004              mov REG[0x4],A
 03C8 8083              xjmp L57
 03CA           L62:
 03CA                   .dbline 136
 03CA           ;                       else if(port == 2) PRT2DR &= ~bitMask;
 03CA 3DFC02            cmp [X-4],2
 03CD B07E              jnz L57
 03CF                   .dbline 136
 03CF 5202              mov A,[X+2]
 03D1 73                cpl A
 03D2 5300              mov [__r0],A
 03D4 5D08              mov A,REG[0x8]
 03D6 2200              and A,[__r0]
 03D8 6008              mov REG[0x8],A
 03DA                   .dbline 137
 03DA           ;                       break;
 03DA 8071              xjmp L57
 03DC           L66:
 03DC                   .dbline 140
 03DC           ;                       
 03DC           ;               case 1:
 03DC           ;                       if(port == 0) PRT0DR |= bitMask;
 03DC 3DFC00            cmp [X-4],0
 03DF B00F              jnz L67
 03E1                   .dbline 140
 03E1 5D00              mov A,REG[0]
 03E3 5300              mov [__r0],A
 03E5 5202              mov A,[X+2]
 03E7 2C00              or [__r0],A
 03E9 5100              mov A,[__r0]
 03EB 6000              mov REG[0],A
 03ED 805E              xjmp L57
 03EF           L67:
 03EF                   .dbline 141
 03EF           ;                       else if(port == 1) PRT1DR |= bitMask;
 03EF 3DFC01            cmp [X-4],1
 03F2 B00F              jnz L69
 03F4                   .dbline 141
 03F4 5D04              mov A,REG[0x4]
 03F6 5300              mov [__r0],A
 03F8 5202              mov A,[X+2]
 03FA 2C00              or [__r0],A
 03FC 5100              mov A,[__r0]
 03FE 6004              mov REG[0x4],A
 0400 804B              xjmp L57
 0402           L69:
 0402                   .dbline 142
 0402           ;                       else if(port == 2) PRT2DR |= bitMask;
 0402 3DFC02            cmp [X-4],2
 0405 B046              jnz L57
 0407                   .dbline 142
 0407 5D08              mov A,REG[0x8]
 0409 5300              mov [__r0],A
 040B 5202              mov A,[X+2]
 040D 2C00              or [__r0],A
 040F 5100              mov A,[__r0]
 0411 6008              mov REG[0x8],A
 0413                   .dbline 143
 0413           ;                       break;   
 0413 8038              xjmp L57
 0415           L73:
 0415                   .dbline 146
 0415           ;                       
 0415           ;               case 2:
 0415           ;                       if(port == 0) PRT0DR ^= bitMask;
 0415 3DFC00            cmp [X-4],0
 0418 B00F              jnz L74
 041A                   .dbline 146
 041A 5D00              mov A,REG[0]
 041C 5300              mov [__r0],A
 041E 5202              mov A,[X+2]
 0420 3400              xor [__r0],A
 0422 5100              mov A,[__r0]
 0424 6000              mov REG[0],A
 0426 8025              xjmp L57
 0428           L74:
 0428                   .dbline 147
 0428           ;                       else if(port == 1) PRT1DR ^= bitMask;
 0428 3DFC01            cmp [X-4],1
 042B B00F              jnz L76
 042D                   .dbline 147
 042D 5D04              mov A,REG[0x4]
 042F 5300              mov [__r0],A
 0431 5202              mov A,[X+2]
 0433 3400              xor [__r0],A
 0435 5100              mov A,[__r0]
 0437 6004              mov REG[0x4],A
 0439 8012              xjmp L57
 043B           L76:
 043B                   .dbline 148
 043B           ;                       else if(port == 2) PRT2DR ^= bitMask;
 043B 3DFC02            cmp [X-4],2
 043E B00D              jnz L57
 0440                   .dbline 148
 0440 5D08              mov A,REG[0x8]
 0442 5300              mov [__r0],A
 0444 5202              mov A,[X+2]
 0446 3400              xor [__r0],A
 0448 5100              mov A,[__r0]
 044A 6008              mov REG[0x8],A
 044C                   .dbline 149
 044C           ;                       break;
 044C                   .dbline 152
 044C           ;                       
 044C           ;               default:
 044C           ;                       break;
 044C           L57:
 044C                   .dbline -2
 044C           L51:
 044C 38FB              add SP,-5
 044E 20                pop X
 044F                   .dbline 0 ; func end
 044F 7F                ret
 0450                   .dbsym l bitMask 2 c
 0450                   .dbsym l i 0 I
 0450                   .dbsym l state -6 c
 0450                   .dbsym l pin -5 c
 0450                   .dbsym l port -4 c
 0450                   .dbend
 0450                   .dbfunc e lcdAssign _lcdAssign fV
 0450           ;    lcdPosition -> X-9
 0450           ;     lcdNumbers -> X-7
 0450           _lcdAssign::
 0450                   .dbline -1
 0450 10                push X
 0451 4F                mov X,SP
 0452                   .dbline 162
 0452           ;       }
 0452           ; }
 0452           ; 
 0452           ; // Prints integers on the LCD
 0452           ; // lcdPosition values:
 0452           ; // 0 = top left
 0452           ; // 1 = top right
 0452           ; // 2 = bottom left
 0452           ; // 3 = bottom right
 0452           ; void lcdAssign(long lcdNumbers, unsigned int lcdPosition) {
 0452                   .dbline 163
 0452           ;       ltoa(lcdBuffer[lcdPosition], lcdNumbers, 10);
 0452 5000              mov A,0
 0454 08                push A
 0455 500A              mov A,10
 0457 08                push A
 0458 52F9              mov A,[X-7]
 045A 08                push A
 045B 52FA              mov A,[X-6]
 045D 08                push A
 045E 52FB              mov A,[X-5]
 0460 08                push A
 0461 52FC              mov A,[X-4]
 0463 08                push A
 0464 52F8              mov A,[X-8]
 0466 5300              mov [__r1],A
 0468 52F7              mov A,[X-9]
 046A 5300              mov [__r0],A
 046C 6500              asl [__r1]
 046E 6B00              rlc [__r0]
 0470 6500              asl [__r1]
 0472 6B00              rlc [__r0]
 0474 6500              asl [__r1]
 0476 6B00              rlc [__r0]
 0478 060000            add [__r1],<_lcdBuffer
 047B 0E0000            adc [__r0],>_lcdBuffer
 047E 5100              mov A,[__r0]
 0480 08                push A
 0481 5100              mov A,[__r1]
 0483 08                push A
 0484 7C0000            xcall _ltoa
 0487 38F8              add SP,-8
 0489                   .dbline -2
 0489           L80:
 0489 20                pop X
 048A                   .dbline 0 ; func end
 048A 7F                ret
 048B                   .dbsym l lcdPosition -9 i
 048B                   .dbsym l lcdNumbers -7 L
 048B                   .dbend
 048B                   .dbfunc e lcdPrint _lcdPrint fV
 048B           _lcdPrint::
 048B                   .dbline -1
 048B                   .dbline 166
 048B           ; }
 048B           ; 
 048B           ; void lcdPrint(void) {
 048B                   .dbline 167
 048B           ;       LCD_Control(0x01);
 048B 10                push X
 048C 5001              mov A,1
 048E 7C0000            xcall _LCD_Control
 0491                   .dbline 169
 0491           ;       
 0491           ;       LCD_Position(0, 0);
 0491 5000              mov A,0
 0493 5700              mov X,0
 0495 7C0000            xcall _LCD_Position
 0498                   .dbline 170
 0498           ;       LCD_PrString(lcdBuffer[0]);
 0498 5000              mov A,>_lcdBuffer
 049A 08                push A
 049B 5000              mov A,<_lcdBuffer
 049D 5C                mov X,A
 049E 18                pop A
 049F 7C0000            xcall _LCD_PrString
 04A2                   .dbline 171
 04A2           ;       LCD_Position(0, 8);
 04A2 5708              mov X,8
 04A4 5000              mov A,0
 04A6 7C0000            xcall _LCD_Position
 04A9                   .dbline 172
 04A9           ;       LCD_PrString(lcdBuffer[1]);
 04A9 5008              mov A,>_lcdBuffer+8
 04AB 08                push A
 04AC 5008              mov A,<_lcdBuffer+8
 04AE 5C                mov X,A
 04AF 18                pop A
 04B0 7C0000            xcall _LCD_PrString
 04B3                   .dbline 173
 04B3           ;       LCD_Position(1, 0);
 04B3 5700              mov X,0
 04B5 5001              mov A,1
 04B7 7C0000            xcall _LCD_Position
 04BA                   .dbline 174
 04BA           ;       LCD_PrString(lcdBuffer[2]);
 04BA 5010              mov A,>_lcdBuffer+16
 04BC 08                push A
 04BD 5010              mov A,<_lcdBuffer+16
 04BF 5C                mov X,A
 04C0 18                pop A
 04C1 7C0000            xcall _LCD_PrString
 04C4                   .dbline 175
 04C4           ;       LCD_Position(1, 8);
 04C4 5708              mov X,8
 04C6 5001              mov A,1
 04C8 7C0000            xcall _LCD_Position
 04CB                   .dbline 176
 04CB           ;       LCD_PrString(lcdBuffer[3]);
 04CB 5018              mov A,>_lcdBuffer+24
 04CD 08                push A
 04CE 5018              mov A,<_lcdBuffer+24
 04D0 5C                mov X,A
 04D1 18                pop A
 04D2 7C0000            xcall _LCD_PrString
 04D5 20                pop X
 04D6                   .dbline -2
 04D6           L81:
 04D6                   .dbline 0 ; func end
 04D6 7F                ret
 04D7                   .dbend
