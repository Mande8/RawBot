                        .module functions.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./functions.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./functions.c
 0000           _lcdBuffer::
 0000                   .blkb 1
                        .area idata(rom,lit)
 0000 00                .byte 0
                        .area data(ram, con, rel)
 0001                   .dbfile ./functions.c
 0001                   .blkb 15
                        .area idata(rom,lit)
 0001 00000000000000000000      .word 0,0,0,0,0
 000B 0000000000        .byte 0,0,0,0,0
                        .area data(ram, con, rel)
 0010                   .dbfile ./functions.c
 0010                   .blkb 16
                        .area idata(rom,lit)
 0010 00000000000000000000      .word 0,0,0,0,0
 001A 000000000000      .byte 0,0,0,0,0,0
                        .area data(ram, con, rel)
 0020                   .dbfile ./functions.c
 0020                   .dbfile C:\Projects\RawBot\RawBot\functions.c
 0020                   .dbsym e lcdBuffer _lcdBuffer A[32:2:16]c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Projects\RawBot\RawBot\functions.c
 0000                   .dbfunc e servoStart _servoStart fV
 0000           ;         period -> X-5
 0000           _servoStart::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002                   .dbline 16
 0002           ; /*************
 0002           ; *  Includes  *
 0002           ; *************/
 0002           ; 
 0002           ; #include "Functions.h"
 0002           ; #include <m8c.h>
 0002           ; #include <stdlib.h>
 0002           ; #include "PSoCAPI.h"
 0002           ; 
 0002           ; char lcdBuffer[2][16] = { 0 };
 0002           ; 
 0002           ; /**********
 0002           ; *  Servo  *
 0002           ; **********/
 0002           ; 
 0002           ; void servoStart(unsigned int period) {
 0002                   .dbline 17
 0002           ;       ServoPWM_WritePeriod(period);
 0002 10                push X
 0003 52FB              mov A,[X-5]
 0005 08                push A
 0006 52FC              mov A,[X-4]
 0008 20                pop X
 0009 7C0000            xcall _ServoPWM_WritePeriod
 000C                   .dbline 18
 000C           ;       ServoPWM_Start();       
 000C 7C0000            xcall _ServoPWM_Start
 000F 20                pop X
 0010                   .dbline -2
 0010           L1:
 0010 20                pop X
 0011                   .dbline 0 ; func end
 0011 7F                ret
 0012                   .dbsym l period -5 i
 0012                   .dbend
 0012                   .dbfunc e servoStop _servoStop fV
 0012           _servoStop::
 0012                   .dbline -1
 0012                   .dbline 21
 0012           ; }
 0012           ; 
 0012           ; void servoStop(void) {
 0012                   .dbline 22
 0012           ;       ServoPWM_Stop(); // Just for uniformity
 0012 10                push X
 0013 7C0000            xcall _ServoPWM_Stop
 0016 20                pop X
 0017                   .dbline -2
 0017           L2:
 0017                   .dbline 0 ; func end
 0017 7F                ret
 0018                   .dbend
 0018                   .dbfunc e servoMove _servoMove fV
 0018           ;          range -> X-9
 0018           ;         middle -> X-7
 0018           ;          angle -> X-5
 0018           _servoMove::
 0018                   .dbline -1
 0018 10                push X
 0019 4F                mov X,SP
 001A                   .dbline 26
 001A           ; }
 001A           ; 
 001A           ; // Servo moving
 001A           ; void servoMove(int angle, unsigned int middle, unsigned int range) {
 001A                   .dbline 27
 001A           ;       ServoPWM_WritePulseWidth(middle + (angle*((range*2)/180)));
 001A 52F8              mov A,[X-8]
 001C 5300              mov [__r1],A
 001E 52F7              mov A,[X-9]
 0020 5300              mov [__r0],A
 0022 6500              asl [__r1]
 0024 6B00              rlc [__r0]
 0026 5000              mov A,0
 0028 08                push A
 0029 50B4              mov A,-76
 002B 08                push A
 002C 5100              mov A,[__r0]
 002E 08                push A
 002F 5100              mov A,[__r1]
 0031 08                push A
 0032 7C0000            xcall __divmodu_16X16_16
 0035 18                pop A
 0036 5300              mov [__r1],A
 0038 18                pop A
 0039 38FE              add SP,-2
 003B 08                push A
 003C 5100              mov A,[__r1]
 003E 08                push A
 003F 52FB              mov A,[X-5]
 0041 08                push A
 0042 52FC              mov A,[X-4]
 0044 08                push A
 0045 7C0000            xcall __mul16
 0048 38FC              add SP,-4
 004A 5F0000            mov [__r1],[__rX]
 004D 5F0000            mov [__r0],[__rY]
 0050 52FA              mov A,[X-6]
 0052 0200              add A,[__r1]
 0054 5300              mov [__r1],A
 0056 52F9              mov A,[X-7]
 0058 0A00              adc A,[__r0]
 005A 10                push X
 005B 08                push A
 005C 5100              mov A,[__r1]
 005E 20                pop X
 005F 7C0000            xcall _ServoPWM_WritePulseWidth
 0062 20                pop X
 0063                   .dbline -2
 0063           L3:
 0063 20                pop X
 0064                   .dbline 0 ; func end
 0064 7F                ret
 0065                   .dbsym l range -9 i
 0065                   .dbsym l middle -7 i
 0065                   .dbsym l angle -5 I
 0065                   .dbend
 0065                   .dbfunc e usTrigSend _usTrigSend fV
 0065           _usTrigSend::
 0065                   .dbline -1
 0065                   .dbline 34
 0065           ; }
 0065           ; 
 0065           ; /***************
 0065           ; *  Ultrasound  *
 0065           ; ***************/
 0065           ; 
 0065           ; void usTrigSend(void) {
 0065                   .dbline 35
 0065           ;       digitalWrite(0, 6, 1); // Start the trigger signal
 0065 5001              mov A,1
 0067 08                push A
 0068 5006              mov A,6
 006A 08                push A
 006B 5000              mov A,0
 006D 08                push A
 006E 9347              xcall _digitalWrite
 0070 38FD              add SP,-3
 0072                   .dbline 36
 0072           ;       Timer8UsTrig_Start(); // Used to measure 10us trigger pulse
 0072 10                push X
 0073 7C0000            xcall _Timer8UsTrig_Start
 0076 20                pop X
 0077                   .dbline -2
 0077           L4:
 0077                   .dbline 0 ; func end
 0077 7F                ret
 0078                   .dbend
 0078                   .dbfunc e usCalculateDistance _usCalculateDistance fI
 0078           ;      usRawTime -> X-7
 0078           _usCalculateDistance::
 0078                   .dbline -1
 0078 10                push X
 0079 4F                mov X,SP
 007A                   .dbline 39
 007A           ; }
 007A           ; 
 007A           ; int usCalculateDistance(unsigned long usRawTime) {
 007A                   .dbline 40
 007A           ;       return (((46400 - usRawTime) / 2) / 58);
 007A 5040              mov A,64
 007C 13FC              sub A,[X-4]
 007E 5300              mov [__r3],A
 0080 50B5              mov A,-75
 0082 1BFB              sbb A,[X-5]
 0084 5300              mov [__r2],A
 0086 5000              mov A,0
 0088 1BFA              sbb A,[X-6]
 008A 5300              mov [__r1],A
 008C 5000              mov A,0
 008E 1BF9              sbb A,[X-7]
 0090 5300              mov [__r0],A
 0092 70FB              and F,-5
 0094 6E00              rrc [__r0]
 0096 6E00              rrc [__r1]
 0098 6E00              rrc [__r2]
 009A 6E00              rrc [__r3]
 009C 5000              mov A,0
 009E 08                push A
 009F 08                push A
 00A0 08                push A
 00A1 503A              mov A,58
 00A3 08                push A
 00A4 5100              mov A,[__r0]
 00A6 08                push A
 00A7 5100              mov A,[__r1]
 00A9 08                push A
 00AA 5100              mov A,[__r2]
 00AC 08                push A
 00AD 5100              mov A,[__r3]
 00AF 08                push A
 00B0 7C0000            xcall __divmodu_32X32_32
 00B3 18                pop A
 00B4 5300              mov [__r3],A
 00B6 18                pop A
 00B7 5300              mov [__r2],A
 00B9 18                pop A
 00BA 18                pop A
 00BB 38FC              add SP,-4
 00BD 5F0000            mov [__r1],[__r3]
 00C0 5F0000            mov [__r0],[__r2]
 00C3                   .dbline -2
 00C3           L5:
 00C3 20                pop X
 00C4                   .dbline 0 ; func end
 00C4 7F                ret
 00C5                   .dbsym l usRawTime -7 l
 00C5                   .dbend
 00C5                   .dbfunc e drive _drive fV
 00C5           ;            dir -> X-4
 00C5           _drive::
 00C5                   .dbline -1
 00C5 10                push X
 00C6 4F                mov X,SP
 00C7 3802              add SP,2
 00C9                   .dbline 50
 00C9           ; }
 00C9           ; 
 00C9           ; /************
 00C9           ; *  Driving  *
 00C9           ; ************/
 00C9           ; 
 00C9           ; // Connections : H-bridge is connected to
 00C9           ; // Used to drive the H-Bridge; think of a numpad for controls
 00C9           ; // IN1 = Port0 Pin0 , IN2 = Port0 Pin1 etc
 00C9           ; void drive(unsigned char dir) {
 00C9                   .dbline 51
 00C9           ;       switch (dir) {
 00C9 52FC              mov A,[X-4]
 00CB 5401              mov [X+1],A
 00CD 560000            mov [X+0],0
 00D0 3D0000            cmp [X+0],0
 00D3 B006              jnz X0
 00D5 3D0102            cmp [X+1],2
 00D8 A02B              jz L10
 00DA           X0:
 00DA 3D0000            cmp [X+0],0
 00DD B006              jnz X1
 00DF 3D0104            cmp [X+1],4
 00E2 A029              jz L11
 00E4           X1:
 00E4 3D0000            cmp [X+0],0
 00E7 B006              jnz X2
 00E9 3D0105            cmp [X+1],5
 00EC A027              jz L12
 00EE           X2:
 00EE 3D0000            cmp [X+0],0
 00F1 B006              jnz X3
 00F3 3D0106            cmp [X+1],6
 00F6 A022              jz L13
 00F8           X3:
 00F8 3D0000            cmp [X+0],0
 00FB B006              jnz X4
 00FD 3D0108            cmp [X+1],8
 0100 A020              jz L14
 0102           X4:
 0102 8026              xjmp L7
 0104           L10:
 0104                   .dbline 53
 0104           ;               case 2: // Back (0101)
 0104           ;                       PRT0DR &= ~0x0A;
 0104 4100F5            and REG[0],-11
 0107                   .dbline 54
 0107           ;                       PRT0DR |= 0x05;
 0107 430005            or REG[0],5
 010A                   .dbline 55
 010A           ;                       break;
 010A 8021              xjmp L8
 010C           L11:
 010C                   .dbline 57
 010C           ;               case 4: // Left (0110)
 010C           ;                       PRT0DR &= ~0x09;
 010C 4100F6            and REG[0],-10
 010F                   .dbline 58
 010F           ;                       PRT0DR |= 0x06;
 010F 430006            or REG[0],6
 0112                   .dbline 59
 0112           ;                       break;
 0112 8019              xjmp L8
 0114           L12:
 0114                   .dbline 61
 0114           ;               case 5: // Stop
 0114           ;                       PRT0DR &= ~0x0F; // All pins low;
 0114 4100F0            and REG[0],-16
 0117                   .dbline 62
 0117           ;                       break;
 0117 8014              xjmp L8
 0119           L13:
 0119                   .dbline 64
 0119           ;               case 6: // Right (1001)
 0119           ;                       PRT0DR &= ~0x06;
 0119 4100F9            and REG[0],-7
 011C                   .dbline 65
 011C           ;                       PRT0DR |= 0x09;
 011C 430009            or REG[0],9
 011F                   .dbline 66
 011F           ;                       break;
 011F 800C              xjmp L8
 0121           L14:
 0121                   .dbline 68
 0121           ;               case 8: // Forward (1010)
 0121           ;                       PRT0DR &= ~0x05;
 0121 4100FA            and REG[0],-6
 0124                   .dbline 69
 0124           ;                       PRT0DR |= 0x0A;
 0124 43000A            or REG[0],10
 0127                   .dbline 70
 0127           ;                       break;
 0127 8004              xjmp L8
 0129           L7:
 0129                   .dbline 72
 0129           ;               default:
 0129           ;                       PRT0DR &= ~0x0F; // All pins low;
 0129 4100F0            and REG[0],-16
 012C                   .dbline 73
 012C           ;                       break;
 012C           L8:
 012C                   .dbline -2
 012C           L6:
 012C 38FE              add SP,-2
 012E 20                pop X
 012F                   .dbline 0 ; func end
 012F 7F                ret
 0130                   .dbsym l dir -4 c
 0130                   .dbend
 0130                   .dbfunc e backlight _backlight fV
 0130           ;         toggle -> X-4
 0130           _backlight::
 0130                   .dbline -1
 0130 10                push X
 0131 4F                mov X,SP
 0132                   .dbline 83
 0132           ;       }       
 0132           ; }
 0132           ; 
 0132           ; 
 0132           ; 
 0132           ; /*****************
 0132           ; *  General PSoC  *
 0132           ; *****************/
 0132           ; 
 0132           ; void backlight(unsigned char toggle) {
 0132                   .dbline 84
 0132           ;       pinMode(2,7,1); // set the pin to strong
 0132 5001              mov A,1
 0134 08                push A
 0135 5007              mov A,7
 0137 08                push A
 0138 5002              mov A,2
 013A 08                push A
 013B 9090              xcall _pinMode
 013D 38FD              add SP,-3
 013F                   .dbline 85
 013F           ;       if (toggle == 0) { BL_Data_ADDR=(BL_DataShadow&=~BL_MASK); }
 013F 3DFC00            cmp [X-4],0
 0142 B00A              jnz L16
 0144                   .dbline 85
 0144                   .dbline 85
 0144 26007F            and [_Port_2_Data_SHADE],127
 0147 5100              mov A,[_Port_2_Data_SHADE]
 0149 6008              mov REG[0x8],A
 014B                   .dbline 85
 014B 801B              xjmp L17
 014D           L16:
 014D                   .dbline 86
 014D           ;       else if (toggle == 1) { BL_Data_ADDR=(BL_DataShadow|=BL_MASK); }
 014D 3DFC01            cmp [X-4],1
 0150 B00A              jnz L18
 0152                   .dbline 86
 0152                   .dbline 86
 0152 2E0080            or [_Port_2_Data_SHADE],-128
 0155 5100              mov A,[_Port_2_Data_SHADE]
 0157 6008              mov REG[0x8],A
 0159                   .dbline 86
 0159 800D              xjmp L19
 015B           L18:
 015B                   .dbline 87
 015B           ;       else if (toggle == 2) { BL_Data_ADDR=(BL_DataShadow^=BL_MASK); }
 015B 3DFC02            cmp [X-4],2
 015E B008              jnz L20
 0160                   .dbline 87
 0160                   .dbline 87
 0160 360080            xor [_Port_2_Data_SHADE],-128
 0163 5100              mov A,[_Port_2_Data_SHADE]
 0165 6008              mov REG[0x8],A
 0167                   .dbline 87
 0167           L20:
 0167           L19:
 0167           L17:
 0167                   .dbline -2
 0167           L15:
 0167 20                pop X
 0168                   .dbline 0 ; func end
 0168 7F                ret
 0169                   .dbsym l toggle -4 c
 0169                   .dbend
 0169                   .dbfunc e lcdAssign _lcdAssign fV
 0169           ;    lcdPosition -> X-9
 0169           ;     lcdNumbers -> X-7
 0169           _lcdAssign::
 0169                   .dbline -1
 0169 10                push X
 016A 4F                mov X,SP
 016B                   .dbline 90
 016B           ; }
 016B           ; 
 016B           ; void lcdAssign(long lcdNumbers, unsigned int lcdPosition) {
 016B                   .dbline 91
 016B           ;       ltoa(lcdBuffer[lcdPosition], lcdNumbers, 10);
 016B 5000              mov A,0
 016D 08                push A
 016E 500A              mov A,10
 0170 08                push A
 0171 52F9              mov A,[X-7]
 0173 08                push A
 0174 52FA              mov A,[X-6]
 0176 08                push A
 0177 52FB              mov A,[X-5]
 0179 08                push A
 017A 52FC              mov A,[X-4]
 017C 08                push A
 017D 52F8              mov A,[X-8]
 017F 5300              mov [__r1],A
 0181 52F7              mov A,[X-9]
 0183 5300              mov [__r0],A
 0185 6500              asl [__r1]
 0187 6B00              rlc [__r0]
 0189 6500              asl [__r1]
 018B 6B00              rlc [__r0]
 018D 6500              asl [__r1]
 018F 6B00              rlc [__r0]
 0191 6500              asl [__r1]
 0193 6B00              rlc [__r0]
 0195 060000            add [__r1],<_lcdBuffer
 0198 0E0000            adc [__r0],>_lcdBuffer
 019B 5100              mov A,[__r0]
 019D 08                push A
 019E 5100              mov A,[__r1]
 01A0 08                push A
 01A1 7C0000            xcall _ltoa
 01A4 38F8              add SP,-8
 01A6                   .dbline -2
 01A6           L22:
 01A6 20                pop X
 01A7                   .dbline 0 ; func end
 01A7 7F                ret
 01A8                   .dbsym l lcdPosition -9 i
 01A8                   .dbsym l lcdNumbers -7 L
 01A8                   .dbend
 01A8                   .dbfunc e lcdPrint _lcdPrint fV
 01A8           _lcdPrint::
 01A8                   .dbline -1
 01A8                   .dbline 94
 01A8           ; }
 01A8           ; 
 01A8           ; void lcdPrint(void) {
 01A8                   .dbline 97
 01A8           ;       // LCD_Control(0x01);
 01A8           ;       
 01A8           ;       LCD_Position(0, 0);
 01A8 10                push X
 01A9 5000              mov A,0
 01AB 5700              mov X,0
 01AD 7C0000            xcall _LCD_Position
 01B0                   .dbline 98
 01B0           ;       LCD_PrString(lcdBuffer[0]);
 01B0 5000              mov A,>_lcdBuffer
 01B2 08                push A
 01B3 5000              mov A,<_lcdBuffer
 01B5 5C                mov X,A
 01B6 18                pop A
 01B7 7C0000            xcall _LCD_PrString
 01BA                   .dbline 99
 01BA           ;       LCD_Position(1, 0);
 01BA 5700              mov X,0
 01BC 5001              mov A,1
 01BE 7C0000            xcall _LCD_Position
 01C1                   .dbline 100
 01C1           ;       LCD_PrString(lcdBuffer[1]);
 01C1 5010              mov A,>_lcdBuffer+16
 01C3 08                push A
 01C4 5010              mov A,<_lcdBuffer+16
 01C6 5C                mov X,A
 01C7 18                pop A
 01C8 7C0000            xcall _LCD_PrString
 01CB 20                pop X
 01CC                   .dbline -2
 01CC           L23:
 01CC                   .dbline 0 ; func end
 01CC 7F                ret
 01CD                   .dbend
 01CD                   .dbfunc e pinMode _pinMode fV
 01CD           ;        bitMask -> X+2
 01CD           ;              i -> X+0
 01CD           ;          state -> X-6
 01CD           ;            pin -> X-5
 01CD           ;           port -> X-4
 01CD           _pinMode::
 01CD                   .dbline -1
 01CD 10                push X
 01CE 4F                mov X,SP
 01CF 3805              add SP,5
 01D1                   .dbline 104
 01D1           ; }
 01D1           ; 
 01D1           ; // Sets the pin mode
 01D1           ; void pinMode(unsigned char port, unsigned char pin, unsigned char state) {
 01D1                   .dbline 106
 01D1           ;       int i;
 01D1           ;       BYTE bitMask = 1;
 01D1 560201            mov [X+2],1
 01D4                   .dbline 107
 01D4           ;       for(i = 0; i < pin; i++) { bitMask *= 2; }
 01D4 560100            mov [X+1],0
 01D7 560000            mov [X+0],0
 01DA 8008              xjmp L29
 01DC           L26:
 01DC                   .dbline 107
 01DC                   .dbline 107
 01DC 6602              asl [X+2]
 01DE                   .dbline 107
 01DE           L27:
 01DE                   .dbline 107
 01DE 7701              inc [X+1]
 01E0 0F0000            adc [X+0],0
 01E3           L29:
 01E3                   .dbline 107
 01E3 52FB              mov A,[X-5]
 01E5 5300              mov [__r1],A
 01E7 5201              mov A,[X+1]
 01E9 1200              sub A,[__r1]
 01EB 5000              mov A,0
 01ED 3180              xor A,-128
 01EF 5300              mov [__rX],A
 01F1 5200              mov A,[X+0]
 01F3 3180              xor A,-128
 01F5 1A00              sbb A,[__rX]
 01F7 CFE4              jc L26
 01F9           X5:
 01F9                   .dbline 109
 01F9           ; 
 01F9           ;       switch (state) {
 01F9 52FA              mov A,[X-6]
 01FB 5404              mov [X+4],A
 01FD 560300            mov [X+3],0
 0200 3D0300            cmp [X+3],0
 0203 B006              jnz X6
 0205 3D0400            cmp [X+4],0
 0208 A017              jz L33
 020A           X6:
 020A 3D0300            cmp [X+3],0
 020D B006              jnz X7
 020F 3D0401            cmp [X+4],1
 0212 A091              jz L40
 0214           X7:
 0214 3D0300            cmp [X+3],0
 0217 B006              jnz X8
 0219 3D0403            cmp [X+4],3
 021C A10E              jz L47
 021E           X8:
 021E 8194              xjmp L31
 0220           L33:
 0220                   .dbline 111
 0220           ;               case 0: // Resistive Pulldown
 0220           ;                       if(port == 0) { PRT0DM2 &= ~bitMask; PRT0DM1 &= ~bitMask; PRT0DM0 &= ~bitMask; }
 0220 3DFC00            cmp [X-4],0
 0223 B028              jnz L34
 0225                   .dbline 111
 0225                   .dbline 111
 0225 5202              mov A,[X+2]
 0227 73                cpl A
 0228 5300              mov [__r0],A
 022A 5D03              mov A,REG[0x3]
 022C 2200              and A,[__r0]
 022E 6003              mov REG[0x3],A
 0230                   .dbline 111
 0230 5202              mov A,[X+2]
 0232 73                cpl A
 0233 5300              mov [__r0],A
 0235 7110              or F,0x10  ; iopage = 1
 0237 5D01              mov A,REG[0x1]
 0239 2200              and A,[__r0]
 023B 6001              mov REG[0x1],A
 023D                   .dbline 111
 023D 5202              mov A,[X+2]
 023F 73                cpl A
 0240 5300              mov [__r0],A
 0242 5D00              mov A,REG[0]
 0244 2200              and A,[__r0]
 0246 6000              mov REG[0],A
 0248                   .dbline 111
 0248 70CF              and F,0xCF      ; iopage = 0
 024A 8168              xjmp L31
 024C           L34:
 024C                   .dbline 112
 024C           ;                       else if(port == 1) { PRT1DM2 &= ~bitMask; PRT1DM1 &= ~bitMask; PRT1DM0 &= ~bitMask; }
 024C 3DFC01            cmp [X-4],1
 024F B028              jnz L36
 0251                   .dbline 112
 0251                   .dbline 112
 0251 5202              mov A,[X+2]
 0253 73                cpl A
 0254 5300              mov [__r0],A
 0256 5D07              mov A,REG[0x7]
 0258 2200              and A,[__r0]
 025A 6007              mov REG[0x7],A
 025C                   .dbline 112
 025C 5202              mov A,[X+2]
 025E 73                cpl A
 025F 5300              mov [__r0],A
 0261 7110              or F,0x10  ; iopage = 1
 0263 5D05              mov A,REG[0x5]
 0265 2200              and A,[__r0]
 0267 6005              mov REG[0x5],A
 0269                   .dbline 112
 0269 5202              mov A,[X+2]
 026B 73                cpl A
 026C 5300              mov [__r0],A
 026E 5D04              mov A,REG[0x4]
 0270 2200              and A,[__r0]
 0272 6004              mov REG[0x4],A
 0274                   .dbline 112
 0274 70CF              and F,0xCF      ; iopage = 0
 0276 813C              xjmp L31
 0278           L36:
 0278                   .dbline 113
 0278           ;                       else if(port == 2) { PRT2DM2 &= ~bitMask; PRT2DM1 &= ~bitMask; PRT2DM0 &= ~bitMask; }
 0278 3DFC02            cmp [X-4],2
 027B B137              jnz L31
 027D                   .dbline 113
 027D                   .dbline 113
 027D 5202              mov A,[X+2]
 027F 73                cpl A
 0280 5300              mov [__r0],A
 0282 5D0B              mov A,REG[0xb]
 0284 2200              and A,[__r0]
 0286 600B              mov REG[0xb],A
 0288                   .dbline 113
 0288 5202              mov A,[X+2]
 028A 73                cpl A
 028B 5300              mov [__r0],A
 028D 7110              or F,0x10  ; iopage = 1
 028F 5D09              mov A,REG[0x9]
 0291 2200              and A,[__r0]
 0293 6009              mov REG[0x9],A
 0295                   .dbline 113
 0295 5202              mov A,[X+2]
 0297 73                cpl A
 0298 5300              mov [__r0],A
 029A 5D08              mov A,REG[0x8]
 029C 2200              and A,[__r0]
 029E 6008              mov REG[0x8],A
 02A0                   .dbline 113
 02A0                   .dbline 114
 02A0           ;                       break;
 02A0 70CF              and F,0xCF      ; iopage = 0
 02A2 8110              xjmp L31
 02A4           L40:
 02A4                   .dbline 116
 02A4           ;               case 1: // Strong
 02A4           ;                       if(port == 0) { PRT0DM2 &= ~bitMask; PRT0DM1 &= ~bitMask; PRT0DM0 |= bitMask; }
 02A4 3DFC00            cmp [X-4],0
 02A7 B029              jnz L41
 02A9                   .dbline 116
 02A9                   .dbline 116
 02A9 5202              mov A,[X+2]
 02AB 73                cpl A
 02AC 5300              mov [__r0],A
 02AE 5D03              mov A,REG[0x3]
 02B0 2200              and A,[__r0]
 02B2 6003              mov REG[0x3],A
 02B4                   .dbline 116
 02B4 5202              mov A,[X+2]
 02B6 73                cpl A
 02B7 5300              mov [__r0],A
 02B9 7110              or F,0x10  ; iopage = 1
 02BB 5D01              mov A,REG[0x1]
 02BD 2200              and A,[__r0]
 02BF 6001              mov REG[0x1],A
 02C1                   .dbline 116
 02C1 5D00              mov A,REG[0]
 02C3 5300              mov [__r0],A
 02C5 5202              mov A,[X+2]
 02C7 2C00              or [__r0],A
 02C9 5100              mov A,[__r0]
 02CB 6000              mov REG[0],A
 02CD                   .dbline 116
 02CD 70CF              and F,0xCF      ; iopage = 0
 02CF 80E3              xjmp L31
 02D1           L41:
 02D1                   .dbline 117
 02D1           ;                       else if(port == 1) { PRT1DM2 &= ~bitMask; PRT1DM1 &= ~bitMask; PRT1DM0 |= bitMask; }
 02D1 3DFC01            cmp [X-4],1
 02D4 B029              jnz L43
 02D6                   .dbline 117
 02D6                   .dbline 117
 02D6 5202              mov A,[X+2]
 02D8 73                cpl A
 02D9 5300              mov [__r0],A
 02DB 5D07              mov A,REG[0x7]
 02DD 2200              and A,[__r0]
 02DF 6007              mov REG[0x7],A
 02E1                   .dbline 117
 02E1 5202              mov A,[X+2]
 02E3 73                cpl A
 02E4 5300              mov [__r0],A
 02E6 7110              or F,0x10  ; iopage = 1
 02E8 5D05              mov A,REG[0x5]
 02EA 2200              and A,[__r0]
 02EC 6005              mov REG[0x5],A
 02EE                   .dbline 117
 02EE 5D04              mov A,REG[0x4]
 02F0 5300              mov [__r0],A
 02F2 5202              mov A,[X+2]
 02F4 2C00              or [__r0],A
 02F6 5100              mov A,[__r0]
 02F8 6004              mov REG[0x4],A
 02FA                   .dbline 117
 02FA 70CF              and F,0xCF      ; iopage = 0
 02FC 80B6              xjmp L31
 02FE           L43:
 02FE                   .dbline 118
 02FE           ;                       else if(port == 2) { PRT2DM2 &= ~bitMask; PRT2DM1 &= ~bitMask; PRT2DM0 |= bitMask; }
 02FE 3DFC02            cmp [X-4],2
 0301 B0B1              jnz L31
 0303                   .dbline 118
 0303                   .dbline 118
 0303 5202              mov A,[X+2]
 0305 73                cpl A
 0306 5300              mov [__r0],A
 0308 5D0B              mov A,REG[0xb]
 030A 2200              and A,[__r0]
 030C 600B              mov REG[0xb],A
 030E                   .dbline 118
 030E 5202              mov A,[X+2]
 0310 73                cpl A
 0311 5300              mov [__r0],A
 0313 7110              or F,0x10  ; iopage = 1
 0315 5D09              mov A,REG[0x9]
 0317 2200              and A,[__r0]
 0319 6009              mov REG[0x9],A
 031B                   .dbline 118
 031B 5D08              mov A,REG[0x8]
 031D 5300              mov [__r0],A
 031F 5202              mov A,[X+2]
 0321 2C00              or [__r0],A
 0323 5100              mov A,[__r0]
 0325 6008              mov REG[0x8],A
 0327                   .dbline 118
 0327                   .dbline 119
 0327           ;                       break;
 0327 70CF              and F,0xCF      ; iopage = 0
 0329 8089              xjmp L31
 032B           L47:
 032B                   .dbline 121
 032B           ;               case 3: // Pull up
 032B           ;                       if(port == 0) { PRT0DM2 &= ~bitMask; PRT0DM1 |= bitMask; PRT0DM0 |= bitMask; }
 032B 3DFC00            cmp [X-4],0
 032E B02A              jnz L48
 0330                   .dbline 121
 0330                   .dbline 121
 0330 5202              mov A,[X+2]
 0332 73                cpl A
 0333 5300              mov [__r0],A
 0335 5D03              mov A,REG[0x3]
 0337 2200              and A,[__r0]
 0339 6003              mov REG[0x3],A
 033B                   .dbline 121
 033B 7110              or F,0x10  ; iopage = 1
 033D 5D01              mov A,REG[0x1]
 033F 5300              mov [__r0],A
 0341 5202              mov A,[X+2]
 0343 2C00              or [__r0],A
 0345 5100              mov A,[__r0]
 0347 6001              mov REG[0x1],A
 0349                   .dbline 121
 0349 5D00              mov A,REG[0]
 034B 5300              mov [__r0],A
 034D 5202              mov A,[X+2]
 034F 2C00              or [__r0],A
 0351 5100              mov A,[__r0]
 0353 6000              mov REG[0],A
 0355                   .dbline 121
 0355 70CF              and F,0xCF      ; iopage = 0
 0357 805B              xjmp L31
 0359           L48:
 0359                   .dbline 122
 0359           ;                       else if(port == 1) { PRT1DM2 &= ~bitMask; PRT1DM1 |= bitMask; PRT1DM0 |= bitMask; }
 0359 3DFC01            cmp [X-4],1
 035C B02A              jnz L50
 035E                   .dbline 122
 035E                   .dbline 122
 035E 5202              mov A,[X+2]
 0360 73                cpl A
 0361 5300              mov [__r0],A
 0363 5D07              mov A,REG[0x7]
 0365 2200              and A,[__r0]
 0367 6007              mov REG[0x7],A
 0369                   .dbline 122
 0369 7110              or F,0x10  ; iopage = 1
 036B 5D05              mov A,REG[0x5]
 036D 5300              mov [__r0],A
 036F 5202              mov A,[X+2]
 0371 2C00              or [__r0],A
 0373 5100              mov A,[__r0]
 0375 6005              mov REG[0x5],A
 0377                   .dbline 122
 0377 5D04              mov A,REG[0x4]
 0379 5300              mov [__r0],A
 037B 5202              mov A,[X+2]
 037D 2C00              or [__r0],A
 037F 5100              mov A,[__r0]
 0381 6004              mov REG[0x4],A
 0383                   .dbline 122
 0383 70CF              and F,0xCF      ; iopage = 0
 0385 802D              xjmp L31
 0387           L50:
 0387                   .dbline 123
 0387           ;                       else if(port == 2) { PRT2DM2 &= ~bitMask; PRT2DM1 |= bitMask; PRT2DM0 |= bitMask; }
 0387 3DFC02            cmp [X-4],2
 038A B028              jnz L31
 038C                   .dbline 123
 038C                   .dbline 123
 038C 5202              mov A,[X+2]
 038E 73                cpl A
 038F 5300              mov [__r0],A
 0391 5D0B              mov A,REG[0xb]
 0393 2200              and A,[__r0]
 0395 600B              mov REG[0xb],A
 0397                   .dbline 123
 0397 7110              or F,0x10  ; iopage = 1
 0399 5D09              mov A,REG[0x9]
 039B 5300              mov [__r0],A
 039D 5202              mov A,[X+2]
 039F 2C00              or [__r0],A
 03A1 5100              mov A,[__r0]
 03A3 6009              mov REG[0x9],A
 03A5                   .dbline 123
 03A5 5D08              mov A,REG[0x8]
 03A7 5300              mov [__r0],A
 03A9 5202              mov A,[X+2]
 03AB 2C00              or [__r0],A
 03AD 5100              mov A,[__r0]
 03AF 6008              mov REG[0x8],A
 03B1                   .dbline 123
 03B1                   .dbline 124
 03B1           ;                       break;
 03B1                   .dbline 126
 03B1           ;               default:
 03B1           ;                       break;
 03B1 70CF              and F,0xCF      ; iopage = 0
 03B3           L31:
 03B3                   .dbline -2
 03B3           L25:
 03B3 38FB              add SP,-5
 03B5 20                pop X
 03B6                   .dbline 0 ; func end
 03B6 7F                ret
 03B7                   .dbsym l bitMask 2 c
 03B7                   .dbsym l i 0 I
 03B7                   .dbsym l state -6 c
 03B7                   .dbsym l pin -5 c
 03B7                   .dbsym l port -4 c
 03B7                   .dbend
 03B7                   .dbfunc e digitalWrite _digitalWrite fV
 03B7           ;        bitMask -> X+2
 03B7           ;              i -> X+0
 03B7           ;          state -> X-6
 03B7           ;            pin -> X-5
 03B7           ;           port -> X-4
 03B7           _digitalWrite::
 03B7                   .dbline -1
 03B7 10                push X
 03B8 4F                mov X,SP
 03B9 3805              add SP,5
 03BB                   .dbline 133
 03BB           ;       } 
 03BB           ; }
 03BB           ; 
 03BB           ; 
 03BB           ; // Function for setting pins
 03BB           ; // 0 = low, 1 = high, 2 = toggle
 03BB           ; void digitalWrite(unsigned char port, unsigned char pin, unsigned char state) {
 03BB                   .dbline 135
 03BB           ;       int i ;
 03BB           ;       BYTE bitMask = 1; 
 03BB 560201            mov [X+2],1
 03BE                   .dbline 136
 03BE           ;       for(i = 0; i < pin; i++) { bitMask *= 2; }
 03BE 560100            mov [X+1],0
 03C1 560000            mov [X+0],0
 03C4 8008              xjmp L58
 03C6           L55:
 03C6                   .dbline 136
 03C6                   .dbline 136
 03C6 6602              asl [X+2]
 03C8                   .dbline 136
 03C8           L56:
 03C8                   .dbline 136
 03C8 7701              inc [X+1]
 03CA 0F0000            adc [X+0],0
 03CD           L58:
 03CD                   .dbline 136
 03CD 52FB              mov A,[X-5]
 03CF 5300              mov [__r1],A
 03D1 5201              mov A,[X+1]
 03D3 1200              sub A,[__r1]
 03D5 5000              mov A,0
 03D7 3180              xor A,-128
 03D9 5300              mov [__rX],A
 03DB 5200              mov A,[X+0]
 03DD 3180              xor A,-128
 03DF 1A00              sbb A,[__rX]
 03E1 CFE4              jc L55
 03E3           X9:
 03E3                   .dbline 138
 03E3           ; 
 03E3           ;       switch (state) {
 03E3 52FA              mov A,[X-6]
 03E5 5404              mov [X+4],A
 03E7 560300            mov [X+3],0
 03EA 3D0300            cmp [X+3],0
 03ED B006              jnz X10
 03EF 3D0400            cmp [X+4],0
 03F2 A017              jz L62
 03F4           X10:
 03F4 3D0300            cmp [X+3],0
 03F7 B006              jnz X11
 03F9 3D0401            cmp [X+4],1
 03FC A043              jz L69
 03FE           X11:
 03FE 3D0300            cmp [X+3],0
 0401 B006              jnz X12
 0403 3D0402            cmp [X+4],2
 0406 A072              jz L76
 0408           X12:
 0408 80A7              xjmp L60
 040A           L62:
 040A                   .dbline 140
 040A           ;               case 0:
 040A           ;                       if(port == 0) PRT0DR &= ~bitMask;
 040A 3DFC00            cmp [X-4],0
 040D B00E              jnz L63
 040F                   .dbline 140
 040F 5202              mov A,[X+2]
 0411 73                cpl A
 0412 5300              mov [__r0],A
 0414 5D00              mov A,REG[0]
 0416 2200              and A,[__r0]
 0418 6000              mov REG[0],A
 041A 8095              xjmp L60
 041C           L63:
 041C                   .dbline 141
 041C           ;                       else if(port == 1) PRT1DR &= ~bitMask;
 041C 3DFC01            cmp [X-4],1
 041F B00E              jnz L65
 0421                   .dbline 141
 0421 5202              mov A,[X+2]
 0423 73                cpl A
 0424 5300              mov [__r0],A
 0426 5D04              mov A,REG[0x4]
 0428 2200              and A,[__r0]
 042A 6004              mov REG[0x4],A
 042C 8083              xjmp L60
 042E           L65:
 042E                   .dbline 142
 042E           ;                       else if(port == 2) PRT2DR &= ~bitMask;
 042E 3DFC02            cmp [X-4],2
 0431 B07E              jnz L60
 0433                   .dbline 142
 0433 5202              mov A,[X+2]
 0435 73                cpl A
 0436 5300              mov [__r0],A
 0438 5D08              mov A,REG[0x8]
 043A 2200              and A,[__r0]
 043C 6008              mov REG[0x8],A
 043E                   .dbline 143
 043E           ;                       break;
 043E 8071              xjmp L60
 0440           L69:
 0440                   .dbline 145
 0440           ;               case 1:
 0440           ;                       if(port == 0) PRT0DR |= bitMask;
 0440 3DFC00            cmp [X-4],0
 0443 B00F              jnz L70
 0445                   .dbline 145
 0445 5D00              mov A,REG[0]
 0447 5300              mov [__r0],A
 0449 5202              mov A,[X+2]
 044B 2C00              or [__r0],A
 044D 5100              mov A,[__r0]
 044F 6000              mov REG[0],A
 0451 805E              xjmp L60
 0453           L70:
 0453                   .dbline 146
 0453           ;                       else if(port == 1) PRT1DR |= bitMask;
 0453 3DFC01            cmp [X-4],1
 0456 B00F              jnz L72
 0458                   .dbline 146
 0458 5D04              mov A,REG[0x4]
 045A 5300              mov [__r0],A
 045C 5202              mov A,[X+2]
 045E 2C00              or [__r0],A
 0460 5100              mov A,[__r0]
 0462 6004              mov REG[0x4],A
 0464 804B              xjmp L60
 0466           L72:
 0466                   .dbline 147
 0466           ;                       else if(port == 2) PRT2DR |= bitMask;
 0466 3DFC02            cmp [X-4],2
 0469 B046              jnz L60
 046B                   .dbline 147
 046B 5D08              mov A,REG[0x8]
 046D 5300              mov [__r0],A
 046F 5202              mov A,[X+2]
 0471 2C00              or [__r0],A
 0473 5100              mov A,[__r0]
 0475 6008              mov REG[0x8],A
 0477                   .dbline 148
 0477           ;                       break; 
 0477 8038              xjmp L60
 0479           L76:
 0479                   .dbline 150
 0479           ;               case 2:
 0479           ;                       if(port == 0) PRT0DR ^= bitMask;
 0479 3DFC00            cmp [X-4],0
 047C B00F              jnz L77
 047E                   .dbline 150
 047E 5D00              mov A,REG[0]
 0480 5300              mov [__r0],A
 0482 5202              mov A,[X+2]
 0484 3400              xor [__r0],A
 0486 5100              mov A,[__r0]
 0488 6000              mov REG[0],A
 048A 8025              xjmp L60
 048C           L77:
 048C                   .dbline 151
 048C           ;                       else if(port == 1) PRT1DR ^= bitMask;
 048C 3DFC01            cmp [X-4],1
 048F B00F              jnz L79
 0491                   .dbline 151
 0491 5D04              mov A,REG[0x4]
 0493 5300              mov [__r0],A
 0495 5202              mov A,[X+2]
 0497 3400              xor [__r0],A
 0499 5100              mov A,[__r0]
 049B 6004              mov REG[0x4],A
 049D 8012              xjmp L60
 049F           L79:
 049F                   .dbline 152
 049F           ;                       else if(port == 2) PRT2DR ^= bitMask;
 049F 3DFC02            cmp [X-4],2
 04A2 B00D              jnz L60
 04A4                   .dbline 152
 04A4 5D08              mov A,REG[0x8]
 04A6 5300              mov [__r0],A
 04A8 5202              mov A,[X+2]
 04AA 3400              xor [__r0],A
 04AC 5100              mov A,[__r0]
 04AE 6008              mov REG[0x8],A
 04B0                   .dbline 153
 04B0           ;                       break;
 04B0                   .dbline 155
 04B0           ;               default:
 04B0           ;                       break;
 04B0           L60:
 04B0                   .dbline -2
 04B0           L54:
 04B0 38FB              add SP,-5
 04B2 20                pop X
 04B3                   .dbline 0 ; func end
 04B3 7F                ret
 04B4                   .dbsym l bitMask 2 c
 04B4                   .dbsym l i 0 I
 04B4                   .dbsym l state -6 c
 04B4                   .dbsym l pin -5 c
 04B4                   .dbsym l port -4 c
 04B4                   .dbend
